diff --git a/src/main/java/com/epeters/raytrace/Camera.java b/src/main/java/com/epeters/raytrace/Camera.java
index 6aaed17..6a982dc 100644
--- a/src/main/java/com/epeters/raytrace/Camera.java
+++ b/src/main/java/com/epeters/raytrace/Camera.java
@@ -1,11 +1,8 @@
 package com.epeters.raytrace;
 
-import com.epeters.raytrace.geometry.Ray;
-import com.epeters.raytrace.utils.Vector;
-
 import static java.lang.Math.tan;
 import static java.lang.Math.toRadians;
-import static com.epeters.raytrace.utils.Utils.randomVectorInUnitDisc;
+import static com.epeters.raytrace.Utils.randomVectorInUnitDisc;
 
 /**
  * Represents the camera in the scene. Knows its position and dimensional info,
diff --git a/src/main/java/com/epeters/raytrace/Image.java b/src/main/java/com/epeters/raytrace/Image.java
deleted file mode 100644
index 8b2ddd0..0000000
--- a/src/main/java/com/epeters/raytrace/Image.java
+++ /dev/null
@@ -1,102 +0,0 @@
-package com.epeters.raytrace;
-
-import com.epeters.raytrace.utils.Vector;
-
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.Writer;
-import java.util.Arrays;
-import java.util.function.BiConsumer;
-import java.util.function.Function;
-
-import static com.epeters.raytrace.utils.Vector.ORIGIN;
-import static com.epeters.raytrace.utils.Utils.time;
-
-/**
- * Interface for a 2D grid of {@link Vector} instances representing colors.
- * Knows how to write itself out to image files.
- */
-public class Image {
-
-    public static final String PREAMBLE = """
-            P3
-            %d %d
-            255
-            """;
-
-    public final int width;
-    public final int height;
-    private final Vector [] data;
-
-    public Image(int width, int height) {
-        this.width = width;
-        this.height = height;
-        this.data = new Vector[width * height];
-        Arrays.fill(data, ORIGIN);
-    }
-
-    public int index(int x, int y) {
-        return y * width + x;
-    }
-
-    public Vector get(int x, int y) {
-        return data[index(x,y)];
-    }
-
-    public void set(int x, int y, Vector val) {
-        data[index(x,y)] = val;
-    }
-
-    public void update(int x, int y, Function<Vector,Vector> func) {
-        int idx = index(x, y);
-        data[idx] = func.apply(data[idx]);
-    }
-
-    public void forEach(BiConsumer<Integer,Integer> func) {
-        for (int y=height-1; y>=0; y--) {
-            for (int x=0; x<width; x++) {
-                func.accept(x, y);
-            }
-        }
-    }
-    public void writePpm(Writer writer) {
-        try {
-            writer.write(String.format(PREAMBLE, width, height));
-            forEach((x, y) -> {
-                int [] rgb = get(x,y).toRgb();
-                try {
-                    writer.write(String.format("%d %d %d\n", rgb[0], rgb[1], rgb[2]));
-                } catch (IOException e) {
-                    throw new RuntimeException(e);
-                }
-            });
-            writer.flush();
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    public void writePpm(String path) {
-        try {
-            FileWriter writer = new FileWriter(path);
-            writePpm(writer);
-            writer.close();
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    public static void main(String [] args) {
-
-        Image image = new Image(256, 256);
-        time(() -> {
-            image.forEach((x, y) -> {
-                double r = x / 255.0;
-                double g = y / 255.0;
-                double b = 0.25;
-                image.set(x, y, new Vector(r, g, b));
-            });
-            image.writePpm("/Users/ed.peters/Desktop/test.ppm");
-        });
-    }
-}
diff --git a/src/main/java/com/epeters/raytrace/Main.java b/src/main/java/com/epeters/raytrace/Main.java
new file mode 100644
index 0000000..95c3255
--- /dev/null
+++ b/src/main/java/com/epeters/raytrace/Main.java
@@ -0,0 +1,30 @@
+package com.epeters.raytrace;
+
+import com.epeters.raytrace.hittables.BoundingVolume;
+import com.epeters.raytrace.hittables.Hit;
+import com.epeters.raytrace.materials.Material;
+import com.epeters.raytrace.solids.Solid;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class Main {
+
+    public static void main(String [] args) {
+
+        Material blue = Material.lambertian(Utils.BLUE);
+        List<Solid> solids = Arrays.asList(
+                Solid.sphere(Vector.vec(1.0, 1.0, -1.0), 0.9, blue),
+                Solid.sphere(Vector.vec(1.0, -1.0, -1.0), 1.0, blue),
+                Solid.sphere(Vector.vec(-1.0, -1.0, -1.0), 1.1, blue),
+                Solid.sphere(Vector.vec(-1.0, 1.0, -1.0), 1.2, blue));
+
+        BoundingVolume volume = BoundingVolume.from(new ArrayList<>(solids));
+
+        Ray ray = new Ray(1.0, 1.0, -1.0);
+        Hit hit = volume.hit(ray, 1e-8, Double.MAX_VALUE);
+        System.err.println(hit.info().get().getSolid());
+    }
+
+}
diff --git a/src/main/java/com/epeters/raytrace/geometry/Ray.java b/src/main/java/com/epeters/raytrace/Ray.java
similarity index 76%
rename from src/main/java/com/epeters/raytrace/geometry/Ray.java
rename to src/main/java/com/epeters/raytrace/Ray.java
index ec58858..3c1b324 100644
--- a/src/main/java/com/epeters/raytrace/geometry/Ray.java
+++ b/src/main/java/com/epeters/raytrace/Ray.java
@@ -1,9 +1,7 @@
-package com.epeters.raytrace.geometry;
+package com.epeters.raytrace;
 
-import com.epeters.raytrace.utils.Vector;
-
-import static com.epeters.raytrace.utils.Vector.ORIGIN;
-import static com.epeters.raytrace.utils.Vector.vec;
+import static com.epeters.raytrace.Vector.ORIGIN;
+import static com.epeters.raytrace.Vector.vec;
 
 /**
  * Represents a ray in 3D space, characterized by an origin and a direction. Direction
diff --git a/src/main/java/com/epeters/raytrace/material/Scatter.java b/src/main/java/com/epeters/raytrace/Scatter.java
similarity index 75%
rename from src/main/java/com/epeters/raytrace/material/Scatter.java
rename to src/main/java/com/epeters/raytrace/Scatter.java
index 6f1ac44..d6672be 100644
--- a/src/main/java/com/epeters/raytrace/material/Scatter.java
+++ b/src/main/java/com/epeters/raytrace/Scatter.java
@@ -1,6 +1,4 @@
-package com.epeters.raytrace.material;
-
-import com.epeters.raytrace.utils.Vector;
+package com.epeters.raytrace;
 
 /**
  * Captures the two important facets of light scattering
diff --git a/src/main/java/com/epeters/raytrace/Scenes.java b/src/main/java/com/epeters/raytrace/Scenes.java
index 8636f97..046a529 100644
--- a/src/main/java/com/epeters/raytrace/Scenes.java
+++ b/src/main/java/com/epeters/raytrace/Scenes.java
@@ -1,22 +1,22 @@
 package com.epeters.raytrace;
 
-import com.epeters.raytrace.material.Material;
-import com.epeters.raytrace.utils.Vector;
+import com.epeters.raytrace.materials.Material;
+import com.epeters.raytrace.solids.Solid;
 
 import java.util.ArrayList;
 import java.util.List;
 
-import static com.epeters.raytrace.utils.Utils.MID_GRAY;
-import static com.epeters.raytrace.utils.Utils.random;
-import static com.epeters.raytrace.utils.Utils.randomVectorInUnitCube;
-import static com.epeters.raytrace.utils.Vector.ORIGIN;
-import static com.epeters.raytrace.utils.Vector.vec;
-import static com.epeters.raytrace.utils.Utils.RED;
-import static com.epeters.raytrace.utils.Utils.BLUE;
-import static com.epeters.raytrace.material.Material.lambertian;
-import static com.epeters.raytrace.material.Material.metal;
-import static com.epeters.raytrace.material.Material.dialectric;
-import static com.epeters.raytrace.Solid.sphere;
+import static com.epeters.raytrace.Utils.MID_GRAY;
+import static com.epeters.raytrace.Utils.random;
+import static com.epeters.raytrace.Utils.randomVectorInUnitCube;
+import static com.epeters.raytrace.Vector.ORIGIN;
+import static com.epeters.raytrace.Vector.vec;
+import static com.epeters.raytrace.Utils.RED;
+import static com.epeters.raytrace.Utils.BLUE;
+import static com.epeters.raytrace.materials.Material.lambertian;
+import static com.epeters.raytrace.materials.Material.metal;
+import static com.epeters.raytrace.materials.Material.dialectric;
+import static com.epeters.raytrace.solids.Solid.sphere;
 import static java.lang.Math.PI;
 import static java.lang.Math.cos;
 
@@ -127,6 +127,8 @@ public class Scenes {
         settings.up = vec(0.0, 1.0, 0.0);
         settings.focalDistance = 10.0;
         settings.aperture = 0.1;
+        settings.imageWidth = 1000;
+        settings.useBoundingVolume = true;
         settings.samplesPerPixel = 500;
         settings.bouncesPerPixel = 50;
         return new Tracer(settings, world);
diff --git a/src/main/java/com/epeters/raytrace/Solid.java b/src/main/java/com/epeters/raytrace/Solid.java
deleted file mode 100644
index 255a90e..0000000
--- a/src/main/java/com/epeters/raytrace/Solid.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package com.epeters.raytrace;
-
-import com.epeters.raytrace.geometry.Geometry;
-import com.epeters.raytrace.geometry.Hit;
-import com.epeters.raytrace.geometry.Ray;
-import com.epeters.raytrace.geometry.Sphere;
-import com.epeters.raytrace.material.Material;
-import com.epeters.raytrace.utils.Vector;
-
-import java.util.List;
-
-/**
- * Combination of geometry and material
- *
- * @param geometry the shape of the solid
- * @param material the material of the solid
- */
-public record Solid(Geometry geometry, Material material) {
-
-    /**
-     * @param ray a ray of interest
-     * @param tmin minimum hit distance
-     * @param tmax maximum hit distance
-     * @return a {@link Hit} calculated using the underlying geometry (null if this is a miss)
-     */
-    public Hit hit(Ray ray, double tmin, double tmax) {
-        double t = geometry.hit(ray, tmin, tmax);
-        return Double.isNaN(t) ? null : Hit.from(this, ray, t);
-    }
-
-    /**
-     * @return the closest hit among the specified solids (null if this is a miss)
-     */
-    static Hit computeHit(List<Solid> solids, Ray ray) {
-        double tmin = 0.000001f;
-        double tcur = Double.MAX_VALUE;
-        Hit best = null;
-        for (Solid solid : solids) {
-            Hit hit = solid.hit(ray, tmin, tcur);
-            if (hit != null) {
-                best = hit;
-                tcur = hit.t();
-            }
-        }
-        return best;
-    }
-
-    /**
-     * @return a spherical solid with the supplied properties
-     */
-    static Solid sphere(Vector center, double radius, Material material) {
-        return new Solid(new Sphere(center, radius), material);
-    }
-}
diff --git a/src/main/java/com/epeters/raytrace/Tracer.java b/src/main/java/com/epeters/raytrace/Tracer.java
index 7c5a8db..0fefc67 100644
--- a/src/main/java/com/epeters/raytrace/Tracer.java
+++ b/src/main/java/com/epeters/raytrace/Tracer.java
@@ -1,20 +1,22 @@
 package com.epeters.raytrace;
 
-import com.epeters.raytrace.geometry.Hit;
-import com.epeters.raytrace.geometry.Ray;
-import com.epeters.raytrace.material.Scatter;
-import com.epeters.raytrace.material.Material;
-import com.epeters.raytrace.utils.Vector;
+import com.epeters.raytrace.hittables.BoundingBox;
+import com.epeters.raytrace.hittables.BoundingVolume;
+import com.epeters.raytrace.hittables.Hit;
+import com.epeters.raytrace.hittables.HitInfo;
+import com.epeters.raytrace.hittables.Hittable;
+import com.epeters.raytrace.hittables.HittableList;
+import com.epeters.raytrace.renderer.Renderer;
+import com.epeters.raytrace.solids.Solid;
 
 import java.util.List;
 
-import static com.epeters.raytrace.utils.Utils.BLACK;
-import static com.epeters.raytrace.utils.Utils.SKY_BLUE;
-import static com.epeters.raytrace.utils.Utils.WHITE;
-import static com.epeters.raytrace.utils.Utils.random;
-import static com.epeters.raytrace.utils.Utils.sqrt;
-import static com.epeters.raytrace.utils.Utils.time;
-import static com.epeters.raytrace.utils.Vector.vec;
+import static com.epeters.raytrace.Utils.BLACK;
+import static com.epeters.raytrace.Utils.SKY_BLUE;
+import static com.epeters.raytrace.Utils.WHITE;
+import static com.epeters.raytrace.Utils.random;
+import static com.epeters.raytrace.Utils.sqrt;
+import static com.epeters.raytrace.Vector.vec;
 
 public class Tracer {
 
@@ -22,8 +24,10 @@ public class Tracer {
     private final int bouncesPerPixel;
     private final double sampleScale;
     private final Camera camera;
-    private final List<Solid> world;
+    private final Hittable world;
     private final double aspectRatio;
+    private final int imageWidth;
+    private final int imageHeight;
 
     public Tracer(TracerSettings settings, List<Solid> world) {
         this.samplesPerPixel = settings.samplesPerPixel;
@@ -31,40 +35,42 @@ public class Tracer {
         this.sampleScale = 1.0 / samplesPerPixel;
         this.aspectRatio = settings.aspectRatio;
         this.camera = new Camera(settings);
-        this.world = world;
+        this.world = settings.useBoundingVolume ? BoundingVolume.from(world) : new HittableList(world);
+        this.imageWidth = settings.imageWidth;
+        this.imageHeight = (int)(imageWidth / settings.aspectRatio);
     }
 
-    /**
-     * Renders an image of the specified width. This is the outer loop of tracing;
-     * it will compute each pixel with the appropriate number of samples and then
-     * scale/correct the resulting color value.
-     */
-    public Image render(int imageWidth) {
-        Image canvas = new Image(imageWidth, (int)(imageWidth / aspectRatio));
-        canvas.forEach((x,y) -> {
-            if (x == 0) {
-                System.err.println("working on row "+y);
-            }
-            for (int s=0; s<samplesPerPixel; s++) {
-                Ray ray = computeRay(canvas, x, y);
-                Vector color = computeColor(ray, bouncesPerPixel);
-                canvas.update(x, y, pixel -> pixel.plus(color));
-            }
-            canvas.update(x, y, (value) -> {
-                double newX = sqrt(value.x() * sampleScale);
-                double newY = sqrt(value.y() * sampleScale);
-                double newZ = sqrt(value.z() * sampleScale);
-                return vec(newX, newY, newZ);
-            });
-        });
-        return canvas;
+    public int getImageWidth() {
+        return imageWidth;
     }
 
-    /** Computes a ray from the camera through the image at the specified x,y, with a little fuzz */
-    private Ray computeRay(Image canvas, int x, int y) {
-        double u = (x + random(-0.5, 0.5)) / (double) (canvas.width - 1);
-        double v = (y + random(-0.5, 0.5)) / (double) (canvas.height - 1);
-        return camera.computeRay(u, v);
+    public int getImageHeight() {
+        return imageHeight;
+    }
+
+    /** Renders a single pixel of the output image */
+    public Vector renderPixel(int x, int y) {
+
+        double pixelX = 0.0;
+        double pixelY = 0.0;
+        double pixelZ = 0.0;
+
+        for (int s=0; s<samplesPerPixel; s++) {
+
+            double u = (x + random(-0.5, 0.5)) / (double) (imageWidth - 1);
+            double v = (y + random(-0.5, 0.5)) / (double) (imageHeight - 1);
+            Ray ray = camera.computeRay(u, v);
+
+            Vector color = computeColor(ray, bouncesPerPixel);
+            pixelX += color.x();
+            pixelY += color.y();
+            pixelZ += color.z();
+        }
+
+        pixelX = sqrt(pixelX * sampleScale);
+        pixelY = sqrt(pixelY * sampleScale);
+        pixelZ = sqrt(pixelZ * sampleScale);
+        return vec(pixelX, pixelY, pixelZ);
     }
 
     /** Determines the color of the scene at the point hit by the specified ray */
@@ -76,20 +82,26 @@ public class Tracer {
         }
 
         // if we don't hit, this ray will contribute the background color
-        Hit hit = Solid.computeHit(world, ray);
+        Hit hit = world.hit(ray, 1e-8, Double.MAX_VALUE);
         if (hit == null) {
             return backgroundColor(ray);
         }
 
+        // if we do have a hit, let's find out more
+        HitInfo info = hit.info().get();
+
         // if the solid doesn't have a material, we'll do normal shading
-        Material material = hit.object().material();
-        if (material == null) {
-            return defaultColor(hit);
+        if (info.getColor() == null) {
+            return defaultColor(info);
+        }
+
+        // if there's no scattering, we're a solid color
+        if (info.getBounce() == null) {
+            return info.getColor();
         }
 
-        Scatter scatter = material.computeScatter(hit);
-        Ray bounceRay = new Ray(hit.point(), scatter.direction());
-        return scatter.attenuation().mul(computeColor(bounceRay, bouncesRemaining-1));
+        Ray bounceRay = new Ray(info.getPoint(), info.getBounce());
+        return info.getColor().mul(computeColor(bounceRay, bouncesRemaining-1));
     }
 
     /** Computes the background color for the specified ray */
@@ -99,13 +111,16 @@ public class Tracer {
     }
 
     /** Computes the default color for an object with no material */
-    private Vector defaultColor(Hit hit) {
-        return hit.normal().plus(WHITE).mul(0.5);
+    private Vector defaultColor(HitInfo info) {
+        return info.getNormal().plus(WHITE).mul(0.5);
     }
 
     public static void main(String [] args) {
+
+        int threads = 7;
+
         Tracer tracer = Scenes.randomWorld();
-        Image image = time(() -> tracer.render(800));
-        image.writePpm("/Users/ed.peters/Desktop/trace.ppm");
+        Renderer renderer = new Renderer(tracer, "trace.png", threads);
+        Utils.time(() -> renderer.render());
     }
 }
diff --git a/src/main/java/com/epeters/raytrace/TracerSettings.java b/src/main/java/com/epeters/raytrace/TracerSettings.java
index 0676200..244d574 100644
--- a/src/main/java/com/epeters/raytrace/TracerSettings.java
+++ b/src/main/java/com/epeters/raytrace/TracerSettings.java
@@ -1,9 +1,7 @@
 package com.epeters.raytrace;
 
-import com.epeters.raytrace.utils.Vector;
-
-import static com.epeters.raytrace.utils.Vector.ORIGIN;
-import static com.epeters.raytrace.utils.Vector.vec;
+import static com.epeters.raytrace.Vector.ORIGIN;
+import static com.epeters.raytrace.Vector.vec;
 
 public class TracerSettings {
 
@@ -14,8 +12,10 @@ public class TracerSettings {
     public double fieldOfView = 90.0;
     public double focalDistance = 1.0;
     public double aperture = 0.0;
+    public int imageWidth = 600;
 
     public int samplesPerPixel = 100;
     public int bouncesPerPixel = 10;
+    public boolean useBoundingVolume = false;
 
 }
diff --git a/src/main/java/com/epeters/raytrace/utils/Utils.java b/src/main/java/com/epeters/raytrace/Utils.java
similarity index 90%
rename from src/main/java/com/epeters/raytrace/utils/Utils.java
rename to src/main/java/com/epeters/raytrace/Utils.java
index 4460021..46fee44 100644
--- a/src/main/java/com/epeters/raytrace/utils/Utils.java
+++ b/src/main/java/com/epeters/raytrace/Utils.java
@@ -1,9 +1,9 @@
-package com.epeters.raytrace.utils;
+package com.epeters.raytrace;
 
-import java.util.Random;
 import java.util.concurrent.Callable;
+import java.util.concurrent.ThreadLocalRandom;
 
-import static com.epeters.raytrace.utils.Vector.vec;
+import static com.epeters.raytrace.Vector.vec;
 
 /**
  * Helpers for common simple stuff
@@ -20,10 +20,8 @@ public class Utils {
     public static final Vector DARK_PINK = vec(0.8, 0.0, 0.4);
     public static final Vector DARK_GREEN = vec(0.0, 0.4, 0.0);
 
-    private static final Random rand = new Random();
-
     public static double random() {
-        return rand.nextDouble();
+        return ThreadLocalRandom.current().nextDouble();
     }
 
     public static double random(double min, double max) {
@@ -34,6 +32,10 @@ public class Utils {
         return vec(random(min, max), random(min, max), random(min, max));
     }
 
+    public static int randomComponent() {
+        return ThreadLocalRandom.current().nextInt(3);
+    }
+
     public static Vector randomVectorInUnitCube() {
         return randomVector(-1.0, 1.0);
     }
diff --git a/src/main/java/com/epeters/raytrace/utils/Vector.java b/src/main/java/com/epeters/raytrace/Vector.java
similarity index 71%
rename from src/main/java/com/epeters/raytrace/utils/Vector.java
rename to src/main/java/com/epeters/raytrace/Vector.java
index 899c03e..889b888 100644
--- a/src/main/java/com/epeters/raytrace/utils/Vector.java
+++ b/src/main/java/com/epeters/raytrace/Vector.java
@@ -1,8 +1,11 @@
-package com.epeters.raytrace.utils;
+package com.epeters.raytrace;
 
-import static com.epeters.raytrace.utils.Utils.randomUnitVector;
-import static com.epeters.raytrace.utils.Utils.scaleInt;
-import static com.epeters.raytrace.utils.Utils.sqrt;
+import static com.epeters.raytrace.Utils.randomUnitVector;
+import static com.epeters.raytrace.Utils.scaleInt;
+import static com.epeters.raytrace.Utils.sqrt;
+
+import static java.lang.Math.min;
+import static java.lang.Math.max;
 
 /**
  * Three-dimensional double vector
@@ -11,6 +14,15 @@ public record Vector(double x, double y, double z) {
 
     public static final Vector ORIGIN = new Vector(0.0, 0.0, 0.0);
 
+    public double component(int which) {
+        return switch (which) {
+            case 0 -> x();
+            case 1 -> y();
+            case 2 -> z();
+            default -> throw new IllegalArgumentException("unknown component "+which);
+        };
+    }
+
     public Vector negate() {
         return new Vector(-x, -y, -z);
     }
@@ -66,11 +78,22 @@ public record Vector(double x, double y, double z) {
         return dot(other) < 0.0f;
     }
 
-    public int [] toRgb() {
-        return new int[]{
-                scaleInt(x, 255),
-                scaleInt(y, 255),
-                scaleInt(z, 255) };
+    public Vector minWith(Vector other) {
+        return vec(min(x, other.x), min(y, other.y), min(z, other.z));
+    }
+
+    public Vector maxWith(Vector other) {
+        return vec(max(x, other.x), max(y, other.y), max(z, other.z));
+    }
+
+    public int toRgb() {
+        int r = scaleInt(x(), 255);
+        int g = scaleInt(y(), 255);
+        int b = scaleInt(z(), 255);
+        r = (r << 16) & 0x00FF0000;
+        g = (g << 8) & 0x0000FF00;
+        b = b & 0x000000FF;
+        return 0xFF000000 | r | g | b;
     }
 
     /**
diff --git a/src/main/java/com/epeters/raytrace/geometry/Geometry.java b/src/main/java/com/epeters/raytrace/geometry/Geometry.java
deleted file mode 100644
index a71ecd9..0000000
--- a/src/main/java/com/epeters/raytrace/geometry/Geometry.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package com.epeters.raytrace.geometry;
-
-import com.epeters.raytrace.utils.Vector;
-
-/**
- * Interface for an object that knows how to determine whether it's hit by
- * a particular ray, and the surface normal at the point of intersection.
- */
-public interface Geometry {
-
-    /**
-     * @param point the point of intersection
-     * @return the outward surface normal (unit vector) at the point of intersection
-     */
-    Vector computeNormal(Vector point);
-
-    /**
-     * @param ray a ray of interest
-     * @param tmin minimum hit distance
-     * @param tmax maximum hit distance
-     * @return t-value for intersection, if there is one within the supplied bounds
-     * ({@link Double#NaN} if there isn't one
-     */
-    double hit(Ray ray, double tmin, double tmax);
-}
diff --git a/src/main/java/com/epeters/raytrace/geometry/Hit.java b/src/main/java/com/epeters/raytrace/geometry/Hit.java
deleted file mode 100644
index 2580789..0000000
--- a/src/main/java/com/epeters/raytrace/geometry/Hit.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package com.epeters.raytrace.geometry;
-
-import com.epeters.raytrace.Solid;
-import com.epeters.raytrace.utils.Vector;
-
-/**
- * Represents the intersection of a ray with an object
- *
- * @param ray the ray in question
- * @param object the object in question
- * @param t the distance along the ray of the intersection
- * @param point the point of intersection
- * @param normal the outward surface normal at the point (unit vector)
- * @param front did the ray hit the front of the face?
- */
-public record Hit(Ray ray, Solid object, double t, Vector point, Vector normal, boolean front) {
-
-    /**
-     * @return normalized direction of the incoming ray
-     */
-    public Vector incoming() {
-        return ray.direction();
-    }
-
-    /**
-     * @return the hit calculated from the supplied parameters
-     */
-    public static Hit from(Solid object, Ray ray, double t) {
-        Vector point = ray.at(t);
-        Vector normal = object.geometry().computeNormal(point);
-        boolean front = ray.direction().isOpposite(normal);
-        return new Hit(ray, object, t, point, front ? normal : normal.negate(), front);
-    }
-}
diff --git a/src/main/java/com/epeters/raytrace/geometry/Sphere.java b/src/main/java/com/epeters/raytrace/geometry/Sphere.java
deleted file mode 100644
index 920bde0..0000000
--- a/src/main/java/com/epeters/raytrace/geometry/Sphere.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package com.epeters.raytrace.geometry;
-
-import com.epeters.raytrace.utils.Vector;
-
-import static com.epeters.raytrace.utils.Utils.sqrt;
-
-/**
- * Implementation of {@link Geometry} logic for a simple sphere.
- */
-public record Sphere(Vector center, double radius) implements Geometry {
-
-    @Override
-    public Vector computeNormal(Vector point) {
-        return point.minus(center).div(radius).normalize();
-    }
-
-    @Override
-    public double hit(Ray ray, double tmin, double tmax) {
-
-        Vector oc = ray.origin().minus(center);
-        double a = ray.direction().square();
-        double hb = oc.dot(ray.direction());
-        double c = oc.square() - radius * radius;
-        double d = hb * hb - a * c;
-        if (d < 0.0) {
-            return Double.NaN;
-        }
-
-        double sd = sqrt(d);
-        double t = (-hb - sd) / a;
-        if (t < tmin || t > tmax) {
-            t = (-hb + sd) / a;
-            if (t < tmin || t > tmax) {
-                return Double.NaN;
-            }
-        }
-
-        return t;
-    }
-}
diff --git a/src/main/java/com/epeters/raytrace/hittables/BoundingBox.java b/src/main/java/com/epeters/raytrace/hittables/BoundingBox.java
new file mode 100644
index 0000000..cc72f7c
--- /dev/null
+++ b/src/main/java/com/epeters/raytrace/hittables/BoundingBox.java
@@ -0,0 +1,65 @@
+package com.epeters.raytrace.hittables;
+
+import com.epeters.raytrace.Ray;
+import com.epeters.raytrace.Vector;
+
+import java.util.List;
+
+/**
+ * AABB
+ * @see <a href="https://raytracing.github.io/books/RayTracingTheNextWeek.html#boundingvolumehierarchies/axis-alignedboundingboxes(aabbs)">guide</a>
+ */
+public class BoundingBox {
+
+    private final Vector min;
+    private final Vector max;
+
+    public BoundingBox(Vector min, Vector max) {
+        this.min = min;
+        this.max = max;
+    }
+
+    public Vector getMin() {
+        return min;
+    }
+
+    public Vector getMax() {
+        return max;
+    }
+
+    public BoundingBox(List<BoundingBox> boxes) {
+        Vector currMin = boxes.get(0).min;
+        Vector currMax = boxes.get(0).max;
+        for (int i=1; i<boxes.size(); i++) {
+            currMin = currMin.minWith(boxes.get(i).min);
+            currMax = currMax.maxWith(boxes.get(i).max);
+        }
+        this.min = currMin;
+        this.max = currMax;
+    }
+
+    public boolean hit(Ray ray, double tmin, double tmax) {
+        for (int a=0; a<3; a++) {
+
+            Vector ro = ray.origin();
+            Vector rd = ray.direction();
+
+            double id = 1.0f / rd.component(a);
+            double t0 = (min.component(a) - ro.component(a)) * id;
+            double t1 = (max.component(a) - ro.component(a)) * id;
+
+            if (id < 0.0f) {
+                double tmp = t1;
+                t1 = t0;
+                t0 = tmp;
+            }
+
+            tmin = t0 > tmin ? t0 : tmin;
+            tmax = t1 < tmax ? t1 : tmax;
+            if (tmax <= tmin) {
+                return false;
+            }
+        }
+        return true;
+    }
+}
diff --git a/src/main/java/com/epeters/raytrace/hittables/BoundingVolume.java b/src/main/java/com/epeters/raytrace/hittables/BoundingVolume.java
new file mode 100644
index 0000000..dc8f97d
--- /dev/null
+++ b/src/main/java/com/epeters/raytrace/hittables/BoundingVolume.java
@@ -0,0 +1,72 @@
+package com.epeters.raytrace.hittables;
+
+import com.epeters.raytrace.Ray;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+
+import static com.epeters.raytrace.Utils.randomComponent;
+
+public class BoundingVolume implements Hittable {
+
+    private final Hittable left;
+    private final Hittable right;
+    private final BoundingBox bounds;
+
+    public BoundingVolume(Hittable left) {
+        this.left = left;
+        this.right = null;
+        this.bounds = left.getBounds();
+    }
+
+    public BoundingVolume(Hittable left, Hittable right) {
+        this.left = left;
+        this.right = right;
+        this.bounds = right != null
+                ? new BoundingBox(Arrays.asList(left.getBounds(), right.getBounds()))
+                : left.getBounds();
+    }
+
+    @Override
+    public BoundingBox getBounds() {
+        return bounds;
+    }
+
+    @Override
+    public Hit hit(Ray ray, double tmin, double tmax) {
+
+        if (!getBounds().hit(ray, tmin, tmax)) {
+            return null;
+        }
+
+        Hit leftHit = left.hit(ray, tmin, tmax);
+        if (right == null) {
+            return leftHit;
+        }
+
+        Hit rightHit = right.hit(ray, tmin, leftHit == null ? tmax : leftHit.t());
+        return (rightHit == null) ? leftHit : rightHit;
+    }
+
+    public static BoundingVolume from(List<? extends Hittable> hittables) {
+
+        if (hittables.size() == 1) {
+            return new BoundingVolume(hittables.get(0));
+        }
+
+        final int c = randomComponent();
+        Collections.sort(hittables, Comparator.comparingDouble(h -> h.getBounds().getMin().component(c)));
+
+        if (hittables.size() == 2) {
+            return new BoundingVolume(hittables.get(0), hittables.get(1));
+        }
+
+        int split = hittables.size() / 2;
+        List<? extends Hittable> left = new ArrayList<>(hittables.subList(0, split));
+        List<? extends Hittable> right = new ArrayList<>(hittables.subList(split, hittables.size()));
+        return new BoundingVolume(from(left), from(right));
+    }
+}
diff --git a/src/main/java/com/epeters/raytrace/hittables/Hit.java b/src/main/java/com/epeters/raytrace/hittables/Hit.java
new file mode 100644
index 0000000..f63bd9b
--- /dev/null
+++ b/src/main/java/com/epeters/raytrace/hittables/Hit.java
@@ -0,0 +1,15 @@
+package com.epeters.raytrace.hittables;
+
+import com.epeters.raytrace.Ray;
+
+import java.util.function.Supplier;
+
+/**
+ * Represents the intersection of a ray with an object
+ *
+ * @param ray the ray in question
+ * @param t the distance along the ray of the intersection
+ * @param info something that can supply additional into about the intersection if asked
+ */
+public record Hit(Ray ray, double t, Supplier<HitInfo> info) {
+}
diff --git a/src/main/java/com/epeters/raytrace/hittables/HitInfo.java b/src/main/java/com/epeters/raytrace/hittables/HitInfo.java
new file mode 100644
index 0000000..7a0debc
--- /dev/null
+++ b/src/main/java/com/epeters/raytrace/hittables/HitInfo.java
@@ -0,0 +1,65 @@
+package com.epeters.raytrace.hittables;
+
+import com.epeters.raytrace.Ray;
+import com.epeters.raytrace.solids.Solid;
+import com.epeters.raytrace.Vector;
+
+public class HitInfo {
+
+    private final Ray ray;
+    private final Solid solid;
+    private final Vector point;
+    private final Vector normal;
+    private final boolean front;
+    private Vector color;
+    private Vector bounce;
+
+    public HitInfo(Ray ray, Solid solid, Vector point, Vector normal) {
+        this.ray = ray;
+        this.solid = solid;
+        this.point = point;
+        if (ray.direction().dot(normal) < 0) {
+            this.front = true;
+            this.normal = normal.normalize();
+        } else {
+            this.front = false;
+            this.normal = normal.negate().normalize();
+        }
+    }
+
+    public Ray getRay() {
+        return ray;
+    }
+
+    public Solid getSolid() {
+        return solid;
+    }
+
+    public Vector getPoint() {
+        return point;
+    }
+
+    public Vector getNormal() {
+        return normal;
+    }
+
+    public boolean isFront() {
+        return front;
+    }
+
+    public Vector getColor() {
+        return color;
+    }
+
+    public Vector getBounce() {
+        return bounce;
+    }
+
+    public void setColor(Vector color) {
+        this.color = color;
+    }
+
+    public void setBounce(Vector bounce) {
+        this.bounce = bounce;
+    }
+}
diff --git a/src/main/java/com/epeters/raytrace/hittables/Hittable.java b/src/main/java/com/epeters/raytrace/hittables/Hittable.java
new file mode 100644
index 0000000..526cd9c
--- /dev/null
+++ b/src/main/java/com/epeters/raytrace/hittables/Hittable.java
@@ -0,0 +1,17 @@
+package com.epeters.raytrace.hittables;
+
+import com.epeters.raytrace.Ray;
+import com.epeters.raytrace.solids.Solid;
+
+/**
+ * Generic interface for "something that can be hit by a {@link Ray}". This might be a
+ * {@link Solid} or a more abstract bounding volume.
+ */
+public interface Hittable {
+
+    /** @return the bounding box for this hittable */
+    BoundingBox getBounds();
+
+    /** @retyrn a new {@link Hit} if this ray hit something; null otherwise */
+    Hit hit(Ray ray, double tmin, double tmax);
+}
diff --git a/src/main/java/com/epeters/raytrace/hittables/HittableList.java b/src/main/java/com/epeters/raytrace/hittables/HittableList.java
new file mode 100644
index 0000000..f5d0aba
--- /dev/null
+++ b/src/main/java/com/epeters/raytrace/hittables/HittableList.java
@@ -0,0 +1,46 @@
+package com.epeters.raytrace.hittables;
+
+import com.epeters.raytrace.Ray;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Collectors;
+
+/**
+ * Implementation of {@link Hittable} that represents a collection of other {@link Hittable}
+ * objects and knows how to compute hits over them all.
+ */
+public class HittableList implements Hittable {
+
+    private final List<Hittable> hittables;
+    private final BoundingBox bounds;
+
+    public HittableList(List<? extends Hittable> c) {
+        this.hittables = new ArrayList<>(c);
+        this.bounds = new BoundingBox(c.stream().map(Hittable::getBounds).collect(Collectors.toList()));
+    }
+
+    @Override
+    public BoundingBox getBounds() {
+        return bounds;
+    }
+
+    @Override
+    public Hit hit(Ray ray, double tmin, double tmax) {
+
+        if (!getBounds().hit(ray, tmin, tmax)) {
+            return null;
+        }
+
+        double tcur = Double.MAX_VALUE;
+        Hit best = null;
+        for (Hittable hittable : hittables) {
+            Hit hit = hittable.hit(ray, tmin, tcur);
+            if (hit != null) {
+                best = hit;
+                tcur = hit.t();
+            }
+        }
+        return best;
+    }
+}
diff --git a/src/main/java/com/epeters/raytrace/material/Material.java b/src/main/java/com/epeters/raytrace/material/Material.java
deleted file mode 100644
index 6a7a315..0000000
--- a/src/main/java/com/epeters/raytrace/material/Material.java
+++ /dev/null
@@ -1,47 +0,0 @@
-package com.epeters.raytrace.material;
-
-import com.epeters.raytrace.geometry.Hit;
-import com.epeters.raytrace.utils.Vector;
-
-import static com.epeters.raytrace.utils.Utils.clamp;
-import static com.epeters.raytrace.utils.Utils.randomUnitVector;
-
-/**
- * Interface for a component that knows how to compute the scattering of light
- * around a hit point.
- */
-public interface Material {
-
-    /**
-     * @param hit an intersection
-     * @return the resulting scattering parameters
-     */
-    Scatter computeScatter(Hit hit);
-
-    /**
-     * Implements "true" Lambertian reflection for a matte material
-     * @see <a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html#diffusematerials/analternativediffuseformulation">guide</a>
-     *
-     * @param color attenuation color
-     * @return a {@link Material} for calculating scatter parameters
-     */
-    static Material lambertian(Vector color) {
-        return (hit) -> new Scatter(color, hit.normal().plus(randomUnitVector()));
-    }
-
-    /**
-     * Implements reflection for metal materials with optional fuzzing
-     *
-     * @param color attenuation color
-     * @param f optional fuzz
-     * @return a {@link Material} for calculating scatter parameters
-     */
-    static Material metal(Vector color, double f) {
-        final double fuzz = clamp(f, 0.0, 1.0);
-        return (hit) -> new Scatter(color, hit.incoming().reflect(hit.normal(), fuzz));
-    }
-
-    static Material dialectric(double backRatio) {
-        return new Dialectric(backRatio);
-    }
-}
diff --git a/src/main/java/com/epeters/raytrace/material/Dialectric.java b/src/main/java/com/epeters/raytrace/materials/DialectricMaterial.java
similarity index 71%
rename from src/main/java/com/epeters/raytrace/material/Dialectric.java
rename to src/main/java/com/epeters/raytrace/materials/DialectricMaterial.java
index 8ad00a8..dfc037c 100644
--- a/src/main/java/com/epeters/raytrace/material/Dialectric.java
+++ b/src/main/java/com/epeters/raytrace/materials/DialectricMaterial.java
@@ -1,29 +1,30 @@
-package com.epeters.raytrace.material;
+package com.epeters.raytrace.materials;
 
-import com.epeters.raytrace.geometry.Hit;
-import com.epeters.raytrace.utils.Vector;
+import com.epeters.raytrace.hittables.HitInfo;
+import com.epeters.raytrace.Vector;
 
-import static com.epeters.raytrace.utils.Utils.WHITE;
-import static com.epeters.raytrace.utils.Utils.random;
-import static com.epeters.raytrace.utils.Utils.sqrt;
-import static com.epeters.raytrace.utils.Utils.square;
+import static com.epeters.raytrace.Utils.WHITE;
+import static com.epeters.raytrace.Utils.random;
+import static com.epeters.raytrace.Utils.sqrt;
+import static com.epeters.raytrace.Utils.square;
 
 import static java.lang.Math.abs;
 
-public class Dialectric implements Material {
+public class DialectricMaterial implements Material {
 
     private final double frontRatio;
     private final double backRatio;
 
-    public Dialectric(double indexOfRefraction) {
+    public DialectricMaterial(double indexOfRefraction) {
         this.frontRatio = 1.0 / indexOfRefraction;
         this.backRatio = indexOfRefraction;
     }
 
     @Override
-    public Scatter computeScatter(Hit hit) {
-        double ratio = hit.front() ? frontRatio : backRatio;
-        return new Scatter(WHITE, refract(hit.incoming(), hit.normal(), ratio));
+    public void computeScatter(HitInfo hit) {
+        double ratio = hit.isFront() ? frontRatio : backRatio;
+        hit.setColor(WHITE);
+        hit.setBounce(refract(hit.getRay().direction(), hit.getNormal(), ratio));
     }
 
     private Vector refract(Vector incoming, Vector normal, double ratio) {
diff --git a/src/main/java/com/epeters/raytrace/materials/LambertianMaterial.java b/src/main/java/com/epeters/raytrace/materials/LambertianMaterial.java
new file mode 100644
index 0000000..6df0057
--- /dev/null
+++ b/src/main/java/com/epeters/raytrace/materials/LambertianMaterial.java
@@ -0,0 +1,25 @@
+package com.epeters.raytrace.materials;
+
+import com.epeters.raytrace.hittables.HitInfo;
+import com.epeters.raytrace.Vector;
+
+import static com.epeters.raytrace.Utils.randomUnitVector;
+
+/**
+ * Implements "true" Lambertian reflection for a matte material
+ * @see <a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html#diffusematerials/analternativediffuseformulation">guide</a>
+ */
+public class LambertianMaterial implements Material {
+
+    private final Vector color;
+
+    public LambertianMaterial(Vector color) {
+        this.color = color;
+    }
+
+    @Override
+    public void computeScatter(HitInfo hit) {
+        hit.setColor(color);
+        hit.setBounce(hit.getNormal().plus(randomUnitVector()));
+    }
+}
diff --git a/src/main/java/com/epeters/raytrace/materials/Material.java b/src/main/java/com/epeters/raytrace/materials/Material.java
new file mode 100644
index 0000000..08089b1
--- /dev/null
+++ b/src/main/java/com/epeters/raytrace/materials/Material.java
@@ -0,0 +1,26 @@
+package com.epeters.raytrace.materials;
+
+import com.epeters.raytrace.hittables.HitInfo;
+import com.epeters.raytrace.Vector;
+
+/**
+ * Interface for a component that knows how to compute the scattering of light
+ * around a hit point.
+ */
+public interface Material {
+
+    /** Computes attenuation and bounce given the supplied hit info */
+    void computeScatter(HitInfo hit);
+
+    static Material lambertian(Vector color) {
+        return new LambertianMaterial(color);
+    }
+
+    static Material metal(Vector color, double fuzz) {
+        return new MetalMaterial(color, fuzz);
+    }
+
+    static Material dialectric(double backRatio) {
+        return new DialectricMaterial(backRatio);
+    }
+}
diff --git a/src/main/java/com/epeters/raytrace/materials/MetalMaterial.java b/src/main/java/com/epeters/raytrace/materials/MetalMaterial.java
new file mode 100644
index 0000000..86fb1b3
--- /dev/null
+++ b/src/main/java/com/epeters/raytrace/materials/MetalMaterial.java
@@ -0,0 +1,28 @@
+package com.epeters.raytrace.materials;
+
+import com.epeters.raytrace.hittables.HitInfo;
+import com.epeters.raytrace.Vector;
+
+import static com.epeters.raytrace.Utils.clamp;
+
+/**
+ * Implements metal reflection with fuzzing
+ * @see <a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html#metal">guide</a>
+ */
+public class MetalMaterial implements Material {
+
+    private final Vector color;
+    private final double fuzz;
+
+    public MetalMaterial(Vector color, double fuzz) {
+        this.color = color;
+        this.fuzz = clamp(fuzz, 0.0, 1.0);
+    }
+
+    @Override
+    public void computeScatter(HitInfo hit) {
+        Vector rd = hit.getRay().direction();
+        hit.setColor(color);
+        hit.setBounce(rd.reflect(hit.getNormal(), fuzz));
+    }
+}
diff --git a/src/main/java/com/epeters/raytrace/renderer/ParallelProgress.java b/src/main/java/com/epeters/raytrace/renderer/ParallelProgress.java
new file mode 100644
index 0000000..8981544
--- /dev/null
+++ b/src/main/java/com/epeters/raytrace/renderer/ParallelProgress.java
@@ -0,0 +1,58 @@
+package com.epeters.raytrace.renderer;
+
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * Implements progress reporting for rendering
+ */
+public final class ParallelProgress {
+
+    private final int pixelsTotal;
+    private double startTime;
+    private double lastIntervalTime;
+    private AtomicInteger pixelsLastInterval;
+    private int pixelsComplete;
+
+    public ParallelProgress(int pixelsTotal) {
+        this.pixelsTotal = pixelsTotal;
+        this.startTime = 0.0;
+        this.lastIntervalTime = 0.0;
+        this.pixelsLastInterval = new AtomicInteger(0);
+        this.pixelsComplete = 0;
+    }
+
+    public void start() {
+        startTime = System.currentTimeMillis();
+        lastIntervalTime = startTime;
+        pixelsLastInterval.set(0);
+        pixelsComplete = 0;
+    }
+
+    public void pixelsComplete(int count) {
+        pixelsLastInterval.addAndGet(count);
+    }
+
+    public void reportProgress() {
+
+        double currentTime = System.currentTimeMillis();
+        double thisIntervalTime = currentTime - lastIntervalTime;
+        lastIntervalTime = currentTime;
+
+        int pixelsThisInterval = pixelsLastInterval.getAndSet(0);
+        pixelsComplete += pixelsThisInterval;
+
+        double freeMemory = Runtime.getRuntime().freeMemory();
+        freeMemory /= Runtime.getRuntime().totalMemory();
+        freeMemory *= 100.0;
+
+        int pctComplete = (int)(pixelsComplete * 100.0 / pixelsTotal);
+        double pixelsPerMinute = pixelsThisInterval / (thisIntervalTime / 60000.0);
+        double minutesLeft = (pixelsTotal - pixelsComplete) / pixelsPerMinute;
+        System.err.printf("%d pixels (%d%%) complete at %.0f pixels/min -> %.3f min remaining (%.3f%% free memory)%n",
+                pixelsComplete,
+                pctComplete,
+                pixelsPerMinute,
+                minutesLeft,
+                freeMemory);
+    }
+}
diff --git a/src/main/java/com/epeters/raytrace/renderer/Renderer.java b/src/main/java/com/epeters/raytrace/renderer/Renderer.java
new file mode 100644
index 0000000..a7a0ac5
--- /dev/null
+++ b/src/main/java/com/epeters/raytrace/renderer/Renderer.java
@@ -0,0 +1,98 @@
+package com.epeters.raytrace.renderer;
+
+import com.epeters.raytrace.Tracer;
+import com.epeters.raytrace.Vector;
+
+import javax.imageio.ImageIO;
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+public class Renderer {
+
+    private final Tracer tracer;
+    private final File file;
+    private final int threads;
+    private final ParallelProgress progress;
+
+    public Renderer(Tracer tracer, String path, int threads) {
+        this.tracer = tracer;
+        this.file = new File(System.getProperty("user.home")+"/Desktop/trace.png");
+        this.threads = threads;
+        this.progress = new ParallelProgress(tracer.getImageWidth() * tracer.getImageHeight());
+    }
+
+    public void render() {
+        List<Vector[]> rows = threads > 1 ? renderThreaded() : renderImmediate();
+        writeData(rows);
+    }
+
+    public List<Vector[]> renderImmediate() {
+        List<Vector[]> rows = new ArrayList<>(tracer.getImageWidth());
+        for (int y=tracer.getImageHeight()-1; y>=0; y--) {
+            rows.add(renderRow(y));
+        }
+        return rows;
+    }
+
+    public List<Vector[]> renderThreaded() {
+
+        ExecutorService executor = Executors.newFixedThreadPool(threads);
+        Map<Integer,Vector[]> rows = new TreeMap<>();
+
+        progress.start();
+        for (int i=0; i<tracer.getImageHeight(); i++) {
+            final int thisRow = i;
+            executor.submit(() -> {
+                rows.put(thisRow, renderRow(thisRow));
+            });
+        }
+        executor.shutdown();
+
+        try {
+            while (!executor.awaitTermination(2000L, TimeUnit.MILLISECONDS)) {
+                progress.reportProgress();
+            }
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        }
+        progress.reportProgress();
+
+        List<Vector[]> list = new ArrayList<>(rows.values());
+        Collections.reverse(list);
+        return list;
+    }
+
+    /** Renders a single row of the image */
+    public Vector [] renderRow(int y) {
+        Vector [] row = new Vector[tracer.getImageWidth()];
+        for (int x=0; x<tracer.getImageWidth(); x++) {
+            row[x] = tracer.renderPixel(x, y);
+            progress.pixelsComplete(1);
+        }
+        return row;
+    }
+
+    public void writeData(List<Vector[]> rows) {
+        BufferedImage image = new BufferedImage(tracer.getImageWidth(), tracer.getImageHeight(), BufferedImage.TYPE_INT_RGB);
+        for (int y=0; y<rows.size(); y++) {
+            Vector [] row = rows.get(y);
+            for (int x=0; x<row.length; x++) {
+                image.setRGB(x, y, row[x].toRgb());
+            }
+        }
+        try {
+            ImageIO.write(image, "png", file);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+}
diff --git a/src/main/java/com/epeters/raytrace/solids/Solid.java b/src/main/java/com/epeters/raytrace/solids/Solid.java
new file mode 100644
index 0000000..c012f07
--- /dev/null
+++ b/src/main/java/com/epeters/raytrace/solids/Solid.java
@@ -0,0 +1,76 @@
+package com.epeters.raytrace.solids;
+
+import com.epeters.raytrace.Ray;
+import com.epeters.raytrace.Vector;
+import com.epeters.raytrace.hittables.BoundingBox;
+import com.epeters.raytrace.hittables.Hit;
+import com.epeters.raytrace.hittables.HitInfo;
+import com.epeters.raytrace.hittables.Hittable;
+import com.epeters.raytrace.materials.Material;
+
+import java.util.function.Supplier;
+
+/**
+ * Implementation of a solid object that knows how to be hit by a ray and act appropriately.
+ * This class mainly handles geometry, and delegates to a {@link Material} to handle scatter.
+ */
+public abstract class Solid implements Hittable {
+
+    private final Material material;
+    private final BoundingBox bounds;
+
+    public Solid(Material material, BoundingBox bounds) {
+        this.material = material;
+        this.bounds = bounds;
+    }
+
+    public Material getMaterial() {
+        return material;
+    }
+
+    @Override
+    public BoundingBox getBounds() {
+        return bounds;
+    }
+
+    /**
+     * @param ray a ray of interest
+     * @param tmin minimum hit distance
+     * @param tmax maximum hit distance
+     * @return a {@link Hit} calculated using the underlying geometry (null if this is a miss)
+     */
+    @Override
+    public Hit hit(Ray ray, double tmin, double tmax) {
+
+        if (!getBounds().hit(ray, tmin, tmax)) {
+            return null;
+        }
+
+        double t = computeHitDistance(ray, tmin, tmax);
+        if (Double.isNaN(t)) {
+            return null;
+        }
+
+        Supplier<HitInfo> supplier = () -> {
+            Vector point = ray.at(t);
+            Vector normal = computeSurfaceNormal(point);
+
+            HitInfo info = new HitInfo(ray, this, point, normal);
+            material.computeScatter(info);
+            return info;
+        };
+
+        return new Hit(ray, t, supplier);
+    }
+
+    protected abstract double computeHitDistance(Ray ray, double tmin, double tmax);
+
+    protected abstract Vector computeSurfaceNormal(Vector point);
+
+    /**
+     * @return a spherical solid with the supplied properties
+     */
+    public static Solid sphere(Vector center, double radius, Material material) {
+        return new Sphere(material, center, radius);
+    }
+}
diff --git a/src/main/java/com/epeters/raytrace/solids/Sphere.java b/src/main/java/com/epeters/raytrace/solids/Sphere.java
new file mode 100644
index 0000000..9536cc1
--- /dev/null
+++ b/src/main/java/com/epeters/raytrace/solids/Sphere.java
@@ -0,0 +1,65 @@
+package com.epeters.raytrace.solids;
+
+import com.epeters.raytrace.Ray;
+import com.epeters.raytrace.Vector;
+import com.epeters.raytrace.hittables.BoundingBox;
+import com.epeters.raytrace.materials.Material;
+
+import static com.epeters.raytrace.Utils.sqrt;
+import static com.epeters.raytrace.Vector.vec;
+import static java.lang.Math.abs;
+
+/**
+ * Concrete implementation of {@link Solid} for a simple sphere.
+ */
+public class Sphere extends Solid {
+
+    private final Vector center;
+    private final double radius;
+
+    public Sphere(Material material, Vector center, double radius) {
+        super(material, computeBounds(center, radius));
+        this.center = center;
+        this.radius = radius;
+    }
+
+    @Override
+    protected double computeHitDistance(Ray ray, double tmin, double tmax) {
+
+        Vector oc = ray.origin().minus(center);
+        double a = ray.direction().square();
+        double hb = oc.dot(ray.direction());
+        double c = oc.square() - radius * radius;
+        double d = hb * hb - a * c;
+        if (d < 0.0) {
+            return Double.NaN;
+        }
+
+        double sd = sqrt(d);
+        double t = (-hb - sd) / a;
+        if (t < tmin || t > tmax) {
+            t = (-hb + sd) / a;
+            if (t < tmin || t > tmax) {
+                return Double.NaN;
+            }
+        }
+
+        return t;
+    }
+
+    public String toString() {
+        return String.format("Sphere[material=%s, center=%s, radius=%.2f]",
+                getMaterial().getClass().getSimpleName(),
+                center, radius);
+    }
+
+    @Override
+    protected Vector computeSurfaceNormal(Vector point) {
+        return point.minus(center).div(radius).normalize();
+    }
+
+    private static BoundingBox computeBounds(Vector center, double radius) {
+        Vector rvec = vec(abs(radius), abs(radius), abs(radius));
+        return new BoundingBox(center.minus(rvec), center.plus(rvec));
+    }
+}
diff --git a/src/test/java/com/epeters/raytrace/TestImage.java b/src/test/java/com/epeters/raytrace/TestImage.java
index fa6cf55..ff1219f 100644
--- a/src/test/java/com/epeters/raytrace/TestImage.java
+++ b/src/test/java/com/epeters/raytrace/TestImage.java
@@ -1,6 +1,5 @@
 package com.epeters.raytrace;
 
-import com.epeters.raytrace.utils.Vector;
 import org.junit.Test;
 
 import java.io.CharArrayWriter;
@@ -10,8 +9,8 @@ import java.io.InputStreamReader;
 import java.io.StringWriter;
 
 import static org.junit.Assert.assertEquals;
-import static com.epeters.raytrace.utils.Vector.ORIGIN;
-import static com.epeters.raytrace.utils.Vector.vec;
+import static com.epeters.raytrace.Vector.ORIGIN;
+import static com.epeters.raytrace.Vector.vec;
 
 public class TestImage {
 
diff --git a/src/test/java/com/epeters/raytrace/geometry/TestRay.java b/src/test/java/com/epeters/raytrace/geometry/TestRay.java
index 66b6b70..bc5b202 100644
--- a/src/test/java/com/epeters/raytrace/geometry/TestRay.java
+++ b/src/test/java/com/epeters/raytrace/geometry/TestRay.java
@@ -1,10 +1,11 @@
 package com.epeters.raytrace.geometry;
 
+import com.epeters.raytrace.Ray;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
-import static com.epeters.raytrace.utils.Vector.ORIGIN;
-import static com.epeters.raytrace.utils.Vector.vec;
+import static com.epeters.raytrace.Vector.ORIGIN;
+import static com.epeters.raytrace.Vector.vec;
 
 public class TestRay {
 
diff --git a/src/test/java/com/epeters/raytrace/utils/TestVector.java b/src/test/java/com/epeters/raytrace/utils/TestVector.java
index 6759a54..3216981 100644
--- a/src/test/java/com/epeters/raytrace/utils/TestVector.java
+++ b/src/test/java/com/epeters/raytrace/utils/TestVector.java
@@ -1,14 +1,14 @@
 package com.epeters.raytrace.utils;
 
-import com.epeters.raytrace.utils.Vector;
+import com.epeters.raytrace.Vector;
 import org.junit.Test;
 
-import static com.epeters.raytrace.utils.Utils.BLUE;
-import static com.epeters.raytrace.utils.Utils.GREEN;
-import static com.epeters.raytrace.utils.Utils.SKY_BLUE;
-import static com.epeters.raytrace.utils.Utils.WHITE;
-import static com.epeters.raytrace.utils.Utils.RED;
-import static com.epeters.raytrace.utils.Vector.vec;
+import static com.epeters.raytrace.Utils.BLUE;
+import static com.epeters.raytrace.Utils.GREEN;
+import static com.epeters.raytrace.Utils.SKY_BLUE;
+import static com.epeters.raytrace.Utils.WHITE;
+import static com.epeters.raytrace.Utils.RED;
+import static com.epeters.raytrace.Vector.vec;
 
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
